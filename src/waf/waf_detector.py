"""
Web Application Firewall (WAF) detection module
"""

import requests
import re
import time
from typing import Dict, List, Optional, Set, Any
from urllib.parse import urljoin


class WAFDetector:
    """
    Detects various types of Web Application Firewalls (WAFs).
    """
    
    def __init__(self):
        """
        Initialize WAF detector with known signatures.
        """
        self.waf_signatures = self._load_waf_signatures()
        self.detection_payloads = self._load_detection_payloads()
    
    def _load_waf_signatures(self) -> Dict[str, Dict[str, List[str]]]:
        """
        Load known WAF signatures for detection.
        
        Returns:
            Dictionary of WAF signatures organized by detection method
        """
        return {
            'headers': {
                'cloudflare': ['cf-ray', 'cloudflare', 'cf-cache-status'],
                'aws_waf': ['x-amzn-requestid', 'x-amzn-trace-id'],
                'akamai': ['akamai', 'x-akamai'],
                'incapsula': ['incap_ses', 'visid_incap', 'x-iinfo'],
                'f5_bigip': ['bigipserver', 'f5-bigip', 'x-waf-event'],
                'barracuda': ['barra', 'barracuda'],
                'fortinet': ['fortigate', 'fortiweb'],
                'checkpoint': ['cp-extension', 'checkpoint'],
                'citrix': ['citrix', 'netscaler'],
                'sophos': ['sophos', 'cyberoam'],
                'imperva': ['x-iinfo', 'incap_ses'],
                'sucuri': ['sucuri', 'x-sucuri'],
                'mod_security': ['mod_security', 'modsecurity'],
                'wallarm': ['wallarm', 'x-wallarm'],
                'sqreen': ['x-sqreen'],
                'wordfence': ['wordfence'],
                'webknight': ['webknight'],
                'naxsi': ['naxsi'],
                'expressionengine': ['set-cookie.*exp_']
            },
            'content': {
                'cloudflare': [
                    'cloudflare ray id',
                    'attention required',
                    'security check',
                    'cf-browser-verification'
                ],
                'aws_waf': [
                    'aws waf',
                    'request blocked',
                    'forbidden.*aws'
                ],
                'akamai': [
                    'reference.*18\..*\..*\..*akamai',
                    'akamai ghost',
                    'policy violation'
                ],
                'incapsula': [
                    'incapsula incident id',
                    'generated by cloudflare',
                    'request unsuccessful'
                ],
                'f5_bigip': [
                    'f5 networks',
                    'bigip',
                    'the requested url was rejected'
                ],
                'barracuda': [
                    'barracuda.*blocked',
                    'request denied by barracuda'
                ],
                'fortinet': [
                    'fortigate',
                    'fortiweb',
                    'blocked by fortinet'
                ],
                'checkpoint': [
                    'checkpoint firewall',
                    'access denied.*checkpoint'
                ],
                'citrix': [
                    'citrix application firewall',
                    'netscaler'
                ],
                'sophos': [
                    'sophos.*blocked',
                    'cyberoam'
                ],
                'imperva': [
                    'imperva.*blocked',
                    'incapsula incident'
                ],
                'sucuri': [
                    'sucuri website firewall',
                    'access denied.*sucuri'
                ],
                'mod_security': [
                    'mod_security',
                    'this error was generated by mod_security'
                ],
                'wallarm': [
                    'blocked by wallarm',
                    'wallarm.*protection'
                ],
                'sqreen': [
                    'blocked by sqreen',
                    'sqreen.*protection'
                ],
                'wordfence': [
                    'generated by wordfence',
                    'wordfence.*blocked'
                ],
                'webknight': [
                    'webknight application firewall',
                    'blocked by webknight'
                ],
                'naxsi': [
                    'naxsi.*blocked',
                    'unusual request blocked'
                ]
            },
            'status_codes': {
                'generic_waf': [406, 501, 503, 999, 419, 429]
            }
        }
    
    def _load_detection_payloads(self) -> List[str]:
        """
        Load payloads specifically designed to trigger WAF responses.
        
        Returns:
            List of detection payloads
        """
        return [
            "' OR '1'='1",
            "1' UNION SELECT 1,2,3--",
            "<script>alert('XSS')</script>",
            "../../../../etc/passwd",
            "SELECT * FROM users WHERE id=1",
            "' AND 1=1--",
            "UNION ALL SELECT NULL,NULL,NULL--",
            "<img src=x onerror=alert(1)>",
            "'; DROP TABLE users;--",
            "1' OR 'a'='a",
            "../../../windows/system32/drivers/etc/hosts",
            "javascript:alert('XSS')",
            "1 UNION SELECT @@version",
            "' HAVING 1=1--",
            "<?php echo 'RCE'; ?>",
            "1' GROUP BY 1,2,3--",
            "' ORDER BY 100--",
            "1' AND SLEEP(5)--",
            "' WAITFOR DELAY '00:00:05'--",
            "1' AND BENCHMARK(5000000,MD5(1))--"
        ]
    
    def detect_waf(self, target_url: str, method: str = 'GET', 
                   parameters: Optional[List[str]] = None) -> Optional[str]:
        """
        Detect WAF presence and type.
        
        Args:
            target_url: Target URL to test
            method: HTTP method to use
            parameters: Parameters to test (if None, will use common ones)
            
        Returns:
            Detected WAF name or None if no WAF detected
        """
        if parameters is None:
            parameters = ['id', 'page', 'cat', 'item']
        
        detected_wafs = set()
        
        # Test 1: Passive detection through normal request
        try:
            response = requests.get(target_url, timeout=10)
            waf = self._analyze_response_for_waf(response)
            if waf:
                detected_wafs.add(waf)
        except Exception:
            pass
        
        # Test 2: Active detection with malicious payloads
        for payload in self.detection_payloads[:5]:  # Limit to first 5 to avoid being too aggressive
            try:
                waf = self._test_payload_for_waf(target_url, payload, method, parameters[0])
                if waf:
                    detected_wafs.add(waf)
                    
                # Small delay between requests
                time.sleep(0.5)
                
            except Exception:
                continue
        
        # Return the most commonly detected WAF
        if detected_wafs:
            return list(detected_wafs)[0]  # Return first detected WAF
        
        return None
    
    def _analyze_response_for_waf(self, response: requests.Response) -> Optional[str]:
        """
        Analyze HTTP response for WAF signatures.
        
        Args:
            response: HTTP response object
            
        Returns:
            Detected WAF name or None
        """
        # Check headers
        for waf_name, header_signatures in self.waf_signatures['headers'].items():
            for signature in header_signatures:
                for header_name, header_value in response.headers.items():
                    if (signature.lower() in header_name.lower() or 
                        signature.lower() in str(header_value).lower()):
                        return waf_name
        
        # Check content
        content = response.text.lower()
        for waf_name, content_signatures in self.waf_signatures['content'].items():
            for signature in content_signatures:
                if re.search(signature.lower(), content):
                    return waf_name
        
        # Check status codes
        if response.status_code in self.waf_signatures['status_codes']['generic_waf']:
            return 'generic_waf'
        
        return None
    
    def _test_payload_for_waf(self, target_url: str, payload: str, method: str, 
                             parameter: str) -> Optional[str]:
        """
        Test a specific payload for WAF detection.
        
        Args:
            target_url: Target URL
            payload: Payload to test
            method: HTTP method
            parameter: Parameter name to inject payload
            
        Returns:
            Detected WAF name or None
        """
        try:
            if method.upper() == 'GET':
                params = {parameter: payload}
                response = requests.get(target_url, params=params, timeout=10)
            else:  # POST
                data = {parameter: payload}
                response = requests.post(target_url, data=data, timeout=10)
            
            return self._analyze_response_for_waf(response)
            
        except Exception:
            return None
    
    def get_waf_bypass_hints(self, waf_name: str) -> Dict[str, List[str]]:
        """
        Get bypass hints for a specific WAF.
        
        Args:
            waf_name: Name of the detected WAF
            
        Returns:
            Dictionary with bypass strategies
        """
        bypass_hints = {
            'cloudflare': {
                'encoding': ['Double URL encoding', 'Unicode encoding'],
                'techniques': ['Case variation', 'Comment insertion', 'Chunked encoding'],
                'payloads': ['Use alternate keywords', 'Fragment requests']
            },
            'mod_security': {
                'encoding': ['URL encoding', 'Hex encoding'],
                'techniques': ['Whitespace manipulation', 'Function obfuscation'],
                'payloads': ['Use CHAR() function', 'Arithmetic expressions']
            },
            'aws_waf': {
                'encoding': ['Base64 encoding', 'Unicode normalization'],
                'techniques': ['Parameter pollution', 'HTTP verb tampering'],
                'payloads': ['JSON injection', 'XML injection']
            },
            'f5_bigip': {
                'encoding': ['IIS encoding', 'Double encoding'],
                'techniques': ['Header injection', 'Cookie injection'],
                'payloads': ['Use alternative functions', 'Timing attacks']
            },
            'generic_waf': {
                'encoding': ['URL encoding', 'HTML entity encoding'],
                'techniques': ['Case manipulation', 'Comment injection'],
                'payloads': ['Basic obfuscation', 'Keyword replacement']
            }
        }
        
        return bypass_hints.get(waf_name, bypass_hints['generic_waf'])
    
    def test_waf_bypass(self, target_url: str, original_payload: str, 
                       bypass_payload: str, method: str = 'GET', 
                       parameter: str = 'id') -> Dict[str, bool]:
        """
        Test if a bypass payload evades WAF detection.
        
        Args:
            target_url: Target URL
            original_payload: Original payload that triggered WAF
            bypass_payload: Modified payload for bypass
            method: HTTP method
            parameter: Parameter name
            
        Returns:
            Dictionary with bypass test results
        """
        results = {
            'original_blocked': False,
            'bypass_successful': False,
            'response_differs': False
        }
        
        try:
            # Test original payload
            if method.upper() == 'GET':
                original_response = requests.get(
                    target_url, 
                    params={parameter: original_payload}, 
                    timeout=10
                )
            else:
                original_response = requests.post(
                    target_url, 
                    data={parameter: original_payload}, 
                    timeout=10
                )
            
            # Test bypass payload
            if method.upper() == 'GET':
                bypass_response = requests.get(
                    target_url, 
                    params={parameter: bypass_payload}, 
                    timeout=10
                )
            else:
                bypass_response = requests.post(
                    target_url, 
                    data={parameter: bypass_payload}, 
                    timeout=10
                )
            
            # Analyze results
            results['original_blocked'] = self._is_blocked_response(original_response)
            bypass_blocked = self._is_blocked_response(bypass_response)
            results['bypass_successful'] = results['original_blocked'] and not bypass_blocked
            results['response_differs'] = original_response.text != bypass_response.text
            
        except Exception:
            pass
        
        return results
    
    def _is_blocked_response(self, response: requests.Response) -> bool:
        """
        Determine if a response indicates the request was blocked.
        
        Args:
            response: HTTP response
            
        Returns:
            True if request appears to be blocked
        """
        # Check status codes typically used by WAFs
        if response.status_code in [403, 406, 501, 503, 999, 419, 429]:
            return True
        
        # Check for blocking keywords in content
        content = response.text.lower()
        blocking_keywords = [
            'blocked', 'forbidden', 'access denied', 'security violation',
            'suspicious activity', 'malicious request', 'threat detected',
            'request rejected', 'policy violation'
        ]
        
        return any(keyword in content for keyword in blocking_keywords)
    
    def analyze_waf_behavior(self, target_url: str, test_payloads: List[str]) -> Dict[str, Any]:
        """
        Analyze WAF behavior patterns with multiple payloads.
        
        Args:
            target_url: Target URL
            test_payloads: List of payloads to test
            
        Returns:
            Analysis of WAF behavior patterns
        """
        behavior_analysis = {
            'blocking_rate': 0.0,
            'blocked_payloads': [],
            'allowed_payloads': [],
            'response_patterns': {},
            'timing_analysis': {},
            'detected_filters': []
        }
        
        blocked_count = 0
        response_times = []
        
        for payload in test_payloads:
            try:
                start_time = time.time()
                response = requests.get(
                    target_url, 
                    params={'id': payload}, 
                    timeout=10
                )
                response_time = time.time() - start_time
                response_times.append(response_time)
                
                if self._is_blocked_response(response):
                    blocked_count += 1
                    behavior_analysis['blocked_payloads'].append(payload)
                else:
                    behavior_analysis['allowed_payloads'].append(payload)
                
                # Analyze response patterns
                status_key = str(response.status_code)
                if status_key not in behavior_analysis['response_patterns']:
                    behavior_analysis['response_patterns'][status_key] = 0
                behavior_analysis['response_patterns'][status_key] += 1
                
                time.sleep(0.2)  # Small delay between requests
                
            except Exception:
                continue
        
        # Calculate metrics
        if test_payloads:
            behavior_analysis['blocking_rate'] = blocked_count / len(test_payloads)
        
        if response_times:
            behavior_analysis['timing_analysis'] = {
                'average_response_time': sum(response_times) / len(response_times),
                'min_response_time': min(response_times),
                'max_response_time': max(response_times)
            }
        
        # Detect filter patterns
        behavior_analysis['detected_filters'] = self._detect_filter_patterns(
            behavior_analysis['blocked_payloads']
        )
        
        return behavior_analysis
    
    def _detect_filter_patterns(self, blocked_payloads: List[str]) -> List[str]:
        """
        Detect filter patterns based on blocked payloads.
        
        Args:
            blocked_payloads: List of payloads that were blocked
            
        Returns:
            List of detected filter patterns
        """
        filters = []
        
        # Check for keyword filters
        keywords = ['select', 'union', 'insert', 'update', 'delete', 'drop']
        for keyword in keywords:
            if any(keyword.lower() in payload.lower() for payload in blocked_payloads):
                filters.append(f'keyword_filter_{keyword}')
        
        # Check for character filters
        special_chars = ["'", '"', '<', '>', '(', ')', ';', '--']
        for char in special_chars:
            if any(char in payload for payload in blocked_payloads):
                filters.append(f'character_filter_{char}')
        
        # Check for length filters
        long_payloads = [p for p in blocked_payloads if len(p) > 50]
        if long_payloads:
            filters.append('length_filter')
        
        return filters
