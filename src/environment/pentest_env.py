"""
Penetration testing environment for SQL injection RL agent
"""

import numpy as np
import requests
import time
from typing import Dict, List, Tuple, Any, Optional
from urllib.parse import urlencode, quote_plus
import logging

from .state_manager import StateManager
from .reward_calculator import RewardCalculator
from ..waf.waf_detector import WAFDetector
from ..payloads.payload_generator import PayloadGenerator
from ..utils.network_utils import NetworkUtils


class PentestEnvironment:
    """
    Environment for training RL agent on SQL injection penetration testing.
    Simulates real-world web application testing scenarios.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None, target_url: Optional[str] = None,
                 state_manager: Optional[StateManager] = None, reward_calculator: Optional[RewardCalculator] = None,
                 waf_detector: Optional[WAFDetector] = None, payload_generator: Optional[PayloadGenerator] = None,
                 network_utils: Optional[NetworkUtils] = None):
        """
        Initialize the penetration testing environment.

        Args:
            config: Environment configuration
            target_url: Target URL for testing
            state_manager: State manager instance
            reward_calculator: Reward calculator instance
            waf_detector: WAF detector instance
            payload_generator: Payload generator instance
            network_utils: Network utilities instance
        """
        self.config = config or {}
        self.target_url = target_url or self.config.get('target_url', 'http://localhost/vulnerable.php')
        self.parameters = self.config.get('parameters', ['id'])
        self.method = self.config.get('method', 'GET')
        self.timeout = self.config.get('timeout', 10)
        self.max_attempts = self.config.get('max_attempts', 100)

        # Environment components
        self.state_manager = state_manager or StateManager(self.config.get('state_config', {}))
        self.reward_calculator = reward_calculator or RewardCalculator(self.config.get('reward_config', {}))
        self.waf_detector = waf_detector or WAFDetector()
        self.payload_generator = payload_generator or PayloadGenerator()
        self.network_utils = network_utils or NetworkUtils()
        
        # Environment state
        self.current_state = None
        self.attempt_count = 0
        self.successful_injections = []
        self.failed_attempts = []
        self.detected_waf = None
        self.baseline_response = None
        
        # Response analysis
        self.response_times = []
        self.response_lengths = []
        self.error_patterns = []
        
        # Setup logging
        self.logger = logging.getLogger(__name__)
        
        # Initialize environment
        self._initialize_environment()
    
    def _initialize_environment(self):
        """
        Initialize the environment and establish baseline.
        """
        try:
            # Get baseline response
            self.baseline_response = self._send_request("")
            
            # Detect WAF
            self.detected_waf = self.waf_detector.detect_waf(self.target_url)
            
            # Initialize state
            self.current_state = self.state_manager.get_initial_state(
                waf_detected=self.detected_waf is not None,
                baseline_response=self.baseline_response
            )
            
            self.logger.info(f"Environment initialized. Target: {self.target_url}")
            if self.detected_waf:
                self.logger.info(f"WAF detected: {self.detected_waf}")
            
        except Exception as e:
            self.logger.error(f"Failed to initialize environment: {e}")
            raise
    
    def reset(self) -> np.ndarray:
        """
        Reset the environment to initial state.
        
        Returns:
            Initial state vector
        """
        self.attempt_count = 0
        self.successful_injections = []
        self.failed_attempts = []
        self.response_times = []
        self.response_lengths = []
        self.error_patterns = []
        
        # Reset state manager
        self.current_state = self.state_manager.get_initial_state(
            waf_detected=self.detected_waf is not None,
            baseline_response=self.baseline_response
        )
        
        return self.state_manager.get_state_vector()
    
    def step(self, action: int, payload: str = None) -> Tuple[np.ndarray, float, bool, Dict[str, Any]]:
        """
        Execute one step in the environment.
        
        Args:
            action: Action to take
            payload: Custom payload (optional)
            
        Returns:
            Tuple of (next_state, reward, done, info)
        """
        self.attempt_count += 1
        
        try:
            # Generate or use provided payload
            if payload is None:
                payload = self.payload_generator.generate_payload(action, self.current_state)
            
            # Apply action to payload
            modified_payload = self._apply_action(action, payload)
            
            # Send request
            response = self._send_request(modified_payload)
            
            # Analyze response
            analysis = self._analyze_response(response, modified_payload)
            
            # Update state
            self.current_state = self.state_manager.update_state(
                action=action,
                payload=modified_payload,
                response=response,
                analysis=analysis,
                attempt_count=self.attempt_count
            )
            
            # Calculate reward
            reward = self.reward_calculator.calculate_reward(
                state=self.current_state,
                action=action,
                response=response,
                analysis=analysis
            )
            
            # Check if episode is done
            done = self._is_episode_done(analysis)
            
            # Prepare info dictionary
            info = {
                'payload': modified_payload,
                'response_code': response.get('status_code', 0),
                'response_time': response.get('response_time', 0),
                'injection_detected': analysis.get('injection_detected', False),
                'waf_triggered': analysis.get('waf_triggered', False),
                'error_detected': analysis.get('error_detected', False),
                'attempt_count': self.attempt_count
            }
            
            # Log results
            self._log_attempt(action, modified_payload, response, analysis, reward)
            
            return self.state_manager.get_state_vector(), reward, done, info
            
        except Exception as e:
            self.logger.error(f"Error in environment step: {e}")
            # Return safe defaults
            return self.state_manager.get_state_vector(), -1.0, True, {'error': str(e)}
    
    def _apply_action(self, action: int, payload: str) -> str:
        """
        Apply the selected action to modify the payload.
        
        Args:
            action: Action index
            payload: Original payload
            
        Returns:
            Modified payload
        """
        # This would interact with the action space and payload generator
        # to apply specific modifications based on the action
        return self.payload_generator.apply_action(action, payload)
    
    def _send_request(self, payload: str) -> Dict[str, Any]:
        """
        Send HTTP request with the payload.
        
        Args:
            payload: Payload to inject
            
        Returns:
            Response information dictionary
        """
        start_time = time.time()
        
        try:
            # Prepare request parameters
            if self.method.upper() == 'GET':
                params = {param: payload for param in self.parameters}
                response = requests.get(
                    self.target_url,
                    params=params,
                    timeout=self.timeout,
                    allow_redirects=False
                )
            else:  # POST
                data = {param: payload for param in self.parameters}
                response = requests.post(
                    self.target_url,
                    data=data,
                    timeout=self.timeout,
                    allow_redirects=False
                )
            
            response_time = time.time() - start_time
            
            return {
                'status_code': response.status_code,
                'headers': dict(response.headers),
                'content': response.text,
                'response_time': response_time,
                'url': response.url
            }
            
        except requests.exceptions.Timeout:
            return {
                'status_code': 0,
                'headers': {},
                'content': '',
                'response_time': self.timeout,
                'url': self.target_url,
                'error': 'timeout'
            }
        except Exception as e:
            return {
                'status_code': 0,
                'headers': {},
                'content': '',
                'response_time': time.time() - start_time,
                'url': self.target_url,
                'error': str(e)
            }
    
    def _analyze_response(self, response: Dict[str, Any], payload: str) -> Dict[str, Any]:
        """
        Analyze the response for injection indicators.
        
        Args:
            response: Response dictionary
            payload: Injected payload
            
        Returns:
            Analysis results
        """
        analysis = {
            'injection_detected': False,
            'waf_triggered': False,
            'error_detected': False,
            'blind_injection_possible': False,
            'response_anomaly': False
        }
        
        content = response.get('content', '')
        status_code = response.get('status_code', 0)
        response_time = response.get('response_time', 0)
        
        # Check for SQL errors
        sql_error_patterns = [
            'mysql_fetch_array',
            'mysql_num_rows',
            'ORA-[0-9]+',
            'Microsoft.*ODBC.*SQL Server',
            'PostgreSQL.*ERROR',
            'Warning.*mysql_',
            'valid MySQL result',
            'MySqlClient.',
            'com.mysql.jdbc',
            'Zend_Db_(Select|Adapter)',
            'Pdo[.]*mysql',
            'MySqlException'
        ]
        
        for pattern in sql_error_patterns:
            if pattern.lower() in content.lower():
                analysis['injection_detected'] = True
                analysis['error_detected'] = True
                break
        
        # Check for WAF responses
        waf_indicators = [
            'blocked',
            'forbidden',
            'access denied',
            'security violation',
            'suspicious activity',
            'malicious request'
        ]
        
        if status_code in [403, 406, 501, 503] or any(indicator in content.lower() for indicator in waf_indicators):
            analysis['waf_triggered'] = True
        
        # Check for union injection success
        if 'union' in payload.lower() and len(content) > len(self.baseline_response.get('content', '')):
            analysis['injection_detected'] = True
        
        # Time-based detection
        if response_time > 5 and 'sleep' in payload.lower():
            analysis['injection_detected'] = True
        
        # Boolean-based blind injection
        if abs(len(content) - len(self.baseline_response.get('content', ''))) > 100:
            analysis['blind_injection_possible'] = True
        
        # Response anomaly detection
        baseline_time = getattr(self, 'baseline_response_time', 1.0)
        if abs(response_time - baseline_time) > 2.0:
            analysis['response_anomaly'] = True
        
        return analysis
    
    def _is_episode_done(self, analysis: Dict[str, Any]) -> bool:
        """
        Check if the episode should terminate.
        
        Args:
            analysis: Response analysis results
            
        Returns:
            True if episode should end
        """
        # Episode ends if injection is successful
        if analysis.get('injection_detected', False):
            return True
        
        # Episode ends if max attempts reached
        if self.attempt_count >= self.max_attempts:
            return True
        
        # Episode ends if WAF consistently blocks requests
        if len(self.failed_attempts) > 10 and all(
            attempt.get('waf_triggered', False) for attempt in self.failed_attempts[-5:]
        ):
            return True
        
        return False
    
    def _log_attempt(self, action: int, payload: str, response: Dict[str, Any], 
                    analysis: Dict[str, Any], reward: float):
        """
        Log the attempt details.
        
        Args:
            action: Action taken
            payload: Payload used
            response: Response received
            analysis: Analysis results
            reward: Reward calculated
        """
        attempt_info = {
            'attempt': self.attempt_count,
            'action': action,
            'payload': payload,
            'status_code': response.get('status_code', 0),
            'response_time': response.get('response_time', 0),
            'analysis': analysis,
            'reward': reward
        }
        
        if analysis.get('injection_detected', False):
            self.successful_injections.append(attempt_info)
            self.logger.info(f"Successful injection detected! Attempt {self.attempt_count}")
        else:
            self.failed_attempts.append(attempt_info)
        
        # Store response metrics
        self.response_times.append(response.get('response_time', 0))
        self.response_lengths.append(len(response.get('content', '')))
    
    def get_environment_stats(self) -> Dict[str, Any]:
        """
        Get environment statistics.
        
        Returns:
            Dictionary with environment statistics
        """
        return {
            'total_attempts': self.attempt_count,
            'successful_injections': len(self.successful_injections),
            'failed_attempts': len(self.failed_attempts),
            'success_rate': len(self.successful_injections) / max(self.attempt_count, 1),
            'average_response_time': np.mean(self.response_times) if self.response_times else 0,
            'waf_detected': self.detected_waf,
            'target_url': self.target_url
        }
    
    def close(self):
        """
        Clean up environment resources.
        """
        self.logger.info("Environment closed")
